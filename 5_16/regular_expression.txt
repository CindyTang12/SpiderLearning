\(?0\d{2}[) -]?\d{8}

\(       -->   转义字符，表示这里有一个(
?        -->   表示前面的(有0个或者1个
0\d{2}   -->   表示0后面接两个任意数字
[) -]?   -->   表示这里有0个或1个的")"或者有0个或1个的"-"
\d{8}    -->   表示有8个数字


\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}

\(       -->   转义字符，表示这里有一个(
0\d{2}   -->   表示0后面接两个任意数字
\(       -->   转义字符，表示这里有一个(
[- ]?    -->   表示这里有0个或1个的"-"或者有0个或1个的" "
\d{8}    -->   表示有8个数字
|        -->   表示另一种情况
0\d{2}   -->   表示0后面接两个任意数字
[- ]?    -->   表示这里有0个或1个的"-"或者有0个或1个的" "
\d{8}    -->   表示有8个数字


\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。
之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。
如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。
原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。


ip地址
(\d{1,3}\.){3}\d{1,3}  但是不准确，因为IP地址中每个数字都不能大于255。
准确写法：
0-99      -->   [1-9]?\d
100-199   -->   1\d{2}
200-249   -->   2[0-4]\d
250-255   -->   25[0-5]

([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]\.){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])


